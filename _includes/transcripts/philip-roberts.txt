>> (Phillip Roberts) hello, come in and sit down. So for the last session before the afternoon break, we have Phillip Roberts who works at Andea and is here from London ‑‑ Scotland. Edinbrough.  ‑‑ wow, ten second memory, he's going to talk about the vent loop. If everyone could give Phillip a big brownedder round of applause.
>> Phillip Roberts:  Okay hello everyone, thanks for coming to the side track, it's awesome to speak a packed room in here. Can everyone give me a stretch. I needed to stretch, so I look less weird. I want to talk about the event loop and what the heck is the event loop, as Mr. The event loop inside JavaScript. So first up, as he said I work for and yet which is an awesome little Dev shop in the US, look us up if you need help with real‑time stuff. That's what we're good at. So, about 18 months ago I'm a paid professional JavaScript developer.  I thought to myself how does, like JavaScript actually work?  And I wasn't entirely sure.  I'd heard V8 as a term, chrome's Runtime didn't really know what that meant, what that did.  I'd heard things like single threaded, obviously I'm using call backs how do call backs work, I started a journey of like reading

 ‑‑ I was kind of like JavaScript what are you. I'm a single threaded single concurrent language ‑‑ yeah, cool, I have a call tack and some other APIs and stuff.  ‑‑ rite. I did not do a computer science degree.  I mean, these words, they're words, soy heard about V8 and the various Runtimes and different browsers so I looked to V8 do you have a call back and queue and other stuff, I have a call stack and a heap, I don't know what those other things are, okay, interesting so basically 18 months passed. And I think I get this. (Laughing) and so, this is what I want to share with you today. Hopefully this will be useful if you're relatively new to JavaScript, help you understand why JavaScript is so weird when you compare it to other languages you might used why call backs are such a thing, cause us hell but are required. And if you're an experienced JavaScript developer hopefully give you some fresh insighter sights how the Runtime you're using works so you can think about it a little better. So if we look at the JavaScript Runtime itself like V8 which is the Runtime inside Chrome. This is a simplified view of what JavaScript Runtime is. The heap, where memory allocation happens, and then there's the call stack, which is where your stack frames are and all that kind of stuff, but, if you, like, clone the V8 code base panned things like time out or DOM or HTTP request, they're not in there, they don't exist in V8, which was a surprise to me. It's first thing you use when you start thinking about Async stuff and it's not in the V8 source. Hmm ... interesting. So, over this 18 months of discovery I come to realize this is really, this is really the bigger picture, this is what I'm hoping to get you on board with today and understand what these pieces are, we have the V8 Runtime but then we have these things called web APIs which are extra things that the Bruce brother vied. DoM, ajacks, time out, things like that, we have this mythical event loop and the call back queue. I'm sure you've heard some of these terms before, but maybe you don't quite understand how these pieces pull together. So, I'm going to start from the beginning, some of this will be new, to words might be new to people, other people will get this. We're going to quickly move on from here, bear with me if this is obvious, I think for a lot of people it's not. So, JavaScript is a single threaded programming language, single threaded Runtime, it has a single call stack. And it can do one thing at a time, that's what a single thread means, the program can run one piece of code at a time. So, let's try and visualize that just to get our heads around what that mean, so if I have some code like this on your left, we've got a few functions, a function multiplier which multiplies two numbers, square which calls multiply with the same number twice, a function which prints the square of a number of calling square and then at the bottom of our file we actually run print square, this code all good?  Make sense?  Cool. So, if we run this, well, I should back up a step, so the call stack is basically ‑‑ it's a data structure which records basically where in the program we are, if we step into a function, we put something on to the stack, if we return from a function, we pop off the top of the stack that's all the stack can do, ‑‑ so if you run this file, there's kind of a main function, right, like the file itself, so, we push that on to the stack. Then we have some function definitions, they're just like defining the state of the world, and finally we got to print square, right, so print area is a function code, so we push that on to the stack, and immediately inside print square, push on to the stack, which calls multiply, now we have a return statement, we multiply A and B and we return, when we return we pop something off the stack, so, pop, multiplier of the stack, returning to square, return to print square, console.log, there's no return, it's implicit, and we're done so that's like a visualization of the call stalk, does that make sense?  (Yes, Bill) even if you haven't thought about the call stack before, you've come across it when you've been doing browser‑side development, so if we have code like this, a function ‑‑ which calls bar, which calls Foo, which throws an error if we run it in Chrom we see this. And it prints the stack trace, right, the state of the stack when that error happened, so, undaughter report oops Foo, bar, Bas, anonymous function, which is our main. Equally, if you've heard the team like blowing the stack, this is an example of that. Have a function which calls Foo return Foo we function calls foo return which calls foo, which calls foo, which calls foo, and ultimately chrome says, you probably didn't mean to call foo 16,000 times recursively, I'll just kill things for you and you can figure out where you bug lies, right. So although I may be representing a new side of the call stack you have some sense of it in your development practice already. So, the big question then comes is like what happens when things are slow?  So, we talk about blocking and blocking behavior and blocking, there's no strict definition of what is and didn't blocking, really it's just code that's slow. So consult.log isn't slow, doing a wild loop from one to ten billion is slow, network requests are slow. Image requests are slow. Things which are slow and on that stack are what are blocking mes. So heres a little example, so let's say we have, this is like a fake bit of code, get synchronous, right, like J curry is like, ajacks request. What would happen if those were synchronous requests, forget what we know about asack call backs they're asynchronous. If we go through it like we have, we call get sink and then we wait, because then we're doing network request, network is relative to computers, are slow, hopefully that network requests completes, we can move on, wait, move on. Wait, and, I mean, this network request might never finish, so ... yeah, I guess I'll go home. Finally those three, you know blocking behaviors complete and we can clear the stack, right. So in a programming language is single threaded you're not using threads like say Ruby, that's what happens, right, we make a network request, we have to just wait till it's done, with have no way of handling that. Why is this actually a problem?  The problem is because we're running code in browsers. So, let's you remember ‑‑ here we go, okay. So this is just, this is Chrome, this is the code I just ran. Browsers don't give us ‑‑ well they do give us asynchronous ajacks request, I'm faking this out with a big wild loop, because it's asynchronous, I basically wild loop for five seconds before continuing, so if I open up the console here. We can see what happens, so with request foo.com, why this is happening, I can't do anything, right, even the run button hasn't finished rerenderring the fact that I clicked it. The browser is blocked, it's stuck, it can't do anything until those requests complete. And then all hell breaks lose because I did some stuff,it figured out I'd done it, it couldn't actually render it. Couldn't do anything. That's because if that call stack has things on it, and here it's got these yeah, it's still going. Weave got the asynchronous request, the browser can't do anything else. It can't render, it can't run any other code, it's stuck. Not ideal, right if we want people to have nice fluid UIs, we can't block the stack. So, how do we handle this?  Well the simplest solution we're provided with is asynchronous call backs, there's almost no call blocking, functions in the browser, equally a node, they're all made asynchronous, which basically means we run some code, give it a call back, come back later, if you've train JavaScript you've seen asynchronous call backs, what does this actually look like. Simple example to remind people where we're at. Code like this, console hi. Write, we run the set time out, but that queue's the console log for future so we scrip on to JSConf and then five seconds later we log "there" right, make sense?  Happy. Basically that's set time out is doing something. So, asynchronous call backs with regards to the stacks we saw before ... how does this work?  Let's run the code. Console.log' ''. We know it doesn't run immediately, we know it's going to run in five seconds time, we can't push it on to the stack, somehow it just disappears, we don't have like a way of describing this yet, we'll come to it. We JSConf, clear, five seconds later somehow magically "there" appears on the stack. How does that happen?  And that's ‑‑ this is basically where the event loop comes in on con currency. Right, so I've been kind of partially lying do you and telling you that JavaScript can only do one thing at one time. That's true the JavaScript Runtime can only do one thing at one time. It can't do a set time out while you're doing another code. The reason we can do things concurrently is that the browser is more than just the Runtime. So, remember this diagram, the JavaScript Runtime can do one thing at a time, but the browser gives us these other things, gives us these we shall APIs, these are effectively threads, you can just make calls to, and those pieces of the browser are aware of this con currency quicks in. If you're back end person this diagram looks basically identical for node, instead of web APIs we have C + + APIs and the threading is being hid from you by C + +. Now we have this picture let's see how it runs in a more full picture of what a browser looks like. So, same as before, run code, console log hi, log of ‑‑ now we can see what happens when we call set time out. We are ‑‑ we pass this call back function and a delay to the set time out call. Now set time out is an API provided to us by the browser, it doesn't live p the V8 source, it's extra stuff we get in that we're running the Java run time in. The browser kicks off a timer for you. And now it east going to handle the count down for you, right, so that means our set time out call, itself is now complete, so we can pop off the stack. Of of JSConf, clear, so, now we've got this timer in the web API, which five seconds later is going to complete. Now the web API can't just start modifying your code, it can't chuck stuff on to the stack when it's ready if it did it would appear randomly in your code so this is where the task queue or call back queue kicks in any of the web API pushes the call back on to the task queue when it's done. Finally we get to the vent loop, title of the talk, the vent loop is like the simplest little piece in this whole equation, and it has one very simple job.

The event loops job is to look at the stack and look at the task queue. If the stack is empty it takes the first thing on the queue and pushes it on to the stack which eventually run it. So here we can see that now the stack is clear, there's a call back on the task queue, the event loop runs, it says, oh, I get to do something, pushes the call back on to the stack. Remember it's the stack is like JavaScript land, back inside V8, the call back appears on the stack, run, log, and we're done. Does that make sense?  Everyone where me?  Awesome! Okay. So, now we can see how this works with probably one of the first encounters you would have had with Async stuff which for some reason says you is to call set time zero, ‑‑ okay, you want me to run the function in zero time?  Like the first time you run across this, if you're like me,i see it doing something, but I don't know why. The reason is, generally, if you're trying to defer something until the stack is clear. So we know looking at this, if you've written JavaScript, that we're going to see the same result, we're going to see JSConf, and there is going to appear at the end. We can see how that happens. The set time out zero, now it's going to complete immediately and push it on to the queue, remember what I said about the vent loop, it has to wait till the stack is clear before it can push the call back on to the stack, so your stack is going to continue to run, console, JSConf and clear, now the event loop can kick in and we're call back. That's like an example like set time out zero, is deferring that execution of code, for whatever reason to the end of the stack. Or until stack is clear. Okay. So, all these web APIs work the same way, if we have ajacks request, we make an ajacks request to the URL with a call back, works the same way, oops sorry, console log, hi, make an ajacks request, the code for running that ajacks request does not live in Java Runtime but in the browser as a web A PI, so we spin it up with a call back in the URL, your code can continue to run. Until that XHR completes, or it may never complete, it's okay, the stack can continue to run, assuming it completes, gets bush to the queue,picked up by the event loop and it's run. That's all that happens when an Async call happens. Let's do a crazy complicated example, I hope the is going to work, if you haven't readized all this is in keynote there's like I don't know 500 abe animation steps in this whole deck. (Applause) J Whew ... no ... so ... interesting, we're given a link. Hmm ... is this big enough, can people see?  Okay, so basically I wrote this talk for Scolto in J S ‑‑ Scotland JS, after the talk I broke after of the slides and could not be bothered to redo all the slides because it was a total pain in the ass in keynote to do it so I took much easier route (Laughing) of writing a tool that can visualize the JavaScript Runtime at Runtime, and it's called loop. So, let's just run this example and, which was kind of the example that we had on the previous slide, I haven't shimmed XHR yet, it's doable just vice‑president done it. As you can see the code, we're going to log something, this is a shim around adamant listener, set time out and we're going to do a ‑‑ I'm going to run it and see what happens so ... at a DOM API, count out, code is going to continue to run, pushes the call back into the queue which runs, and we're done. If I click on here then it's going to ... trigger the web API, queue the call back for the click and run it if, if I cluck a hundred times we can see what happens. If I clicked the click doesn't get processed immediately, itself gets pushed to the queue, as the queue gets processed, eventually my click is going to get dealt with, right. Say a few more examples I'm going to run through here. Here we go, okay, so, I'm just going to run through a few examples just to kind of talk about a few things that you might have run in to and not thought about with Async API, we call set time out four times with the one second delay, and JSConf.hi. By the time the call backs get queued the fourth call back we asked for a one second delay, and it's still waiting, the call back hasn't run, right .

this illustrates the ‑‑ like what time out is actually doing, it's not a guaranteed time to execution, it's a minimum time to execution, it doesn't run the code immediately it runs the code next‑ish, sometime, right?  So ... in this example I want to talk about call backs, so, depending on who, speak to and how they phrase things, call backs can be one of two things, call backs can be any function that another function calls or call backs can be more explicitly an asynchronous call back as in one that will get pushed back on the call back queue in the future this illustrates the difference, right. The four each method on an array, it doesn't run, it takes a function, which you could call a call back, but it's not running it asynchronously, it's running it within the current stack. We could define an asynchronous for it so it can take an array, a bauble and for each item in the array it's going to do a set time out zero with that call back, I guess this should pass in the value, but any way, so, I'm going to run it and we can see what the difference is, so for the first block of code that runs, it's going to sit and block the stack, right?  Until it's complete, whereas in the Async version, okay, it's slowed down, but we oar basically going to cue a bunch of call babblings and they're going to clear and then we can actually run through and do a console.log. In this you remember it's fast, the benefit of doing it asynchronously is not obviously but if you're doing some slow processing on each element in the array.  I think I have that shown somewhere no, no, I don't. Okay. So let's say ‑‑ Ooops. So Iv a question lay function which is just slow, it's just a slow thing. So ... let's said processing Async and here processing Sync. Okay, now, I'm going to turn on a thing I've literally hacked together this morning, which is to simulate the repaint or the render in the browser, something I haven't touched on is how all of this interacts with rendering ‑‑ I've kind of touched on it but not really explained it. So, basically the browser is kind of constrained by what you're doing in I didn't want, the browser would like to repaint the screen every 16.6 milliseconds, 60 frame a second is our you deal, that's the face it will do repaints if it can. But it's constrained by what you're doing in JavaScript for various reasons, so it can't actually do a render if there is code on the stack, right. Like the render kind of is almost like a call become itself. It has to wait till the stack is clear. The difference is that the render is given a highier priority than your call back, everyic is teen milliseconds it's going to cue a rend, wait till the stack is clear before it can actually do that render. So this is ‑‑ this render queue is just similar plaiting a render, every second it's can I do a reppedder?  Yes, can I do a reppedder?  Where, because our code isn't doing anything now. If I run the code, you can see while with're doing this slow synchronous loop through the array, our render is blocked, right, if our render is blocked you can't select text on the screen, you can't click things and see the response, right, like the example I showed earlier. P in this example, okay, it's blocked while we queue up the asink time out, that relatively quick but we're given ‑‑ we're kind of giving the render a chance to sink up asynchronously to jump in there and do the render, does that make sense?

>> Yeah
>> Yeah, cool. So, that's just kind of ‑‑ this is just like a simulation of how the rendering works, but it just rally shows you when people say adopt block the vent loop, this is exactly what they're talking about. They're saying don't put shitty code on the stack then the browser can't do what it needs to do, create a nice fluid UI. Animating too many things gets sluggish if you're not careful about how you queue up that code. So an example of that, we can see where the scroll handlers ‑‑ so scroll handle ‑‑ like scroll events in the DOM trigger a lot, right, they trigger like ‑‑ I presume they trigger on every frame like every 16 milliseconds, if I have code like this this right. On document.scroll, animate something, or do some work.  If I have this code, like as I scroll it's going to queue up like a ton of call backs right. And then it has to go through and process all of those and each of the processing of those is slow, then, okay, you're not blocking the stack, you're flooding the queue with queue it events. So, this is like just helping visualize, I guess, what happens when you actually trigger all these call backs, there's way you can debounce that to basically say okay, we're going to queue up all those vents, but let's do the slow work every few seconds or unthe ill the user stops scrolling for some amount of time I think that's basically it. There's a whole other talk in our the hell this works. Because basically in running the code, like this code runs at Runtime, right, slow down I run it through a Esprema a parter, a Ie insert a big wild loop, that takes half a second, it just slow motions the code. Ship it to web worker and do a whole bunch of stuff to visualize what's happening while doing it at run time that makes sense. A whole other talk in that. I'm super excited about it and will talk to anyone about it after because I think it's kind of neat, so with that, thanks very much ( applause)
Phi
